Without Memoization : 
======================
    /*
public  boolean wordBreak(String s,Set<String> dict) {
        return recurse(0,s,dict);
    }
    public  boolean recurse(int startIndex, String s, Set<String> dict) {
int size = s.length();
        if(startIndex == size) {
            return true;
        }
        boolean state = false;
        int currIndex = startIndex+1;
        while(currIndex <= size) {
            String leftString = s.substring(startIndex,currIndex);
            if(dict.contains(leftString)) {
                state |= recurse(currIndex,s,dict);
            }
            currIndex++;
        }
        return state;
    }
    */
    
With Memoziation
================



import java.util.*;

public class Solution {
    public static void main(String[] args) {
        Set<String> dict = new HashSet<String>();
        dict.add("a");
        dict.add("aa");
        dict.add("aaa");
        dict.add("aaaa");
        dict.add("aaaaa");
        dict.add("aaaaaa");
        dict.add("aaaaaaa");
        dict.add("aaaaaaaa");
        dict.add("aaaaaaaaa");
        dict.add("aaaaaaaaaa");




        String s= new String("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab");

        if(wordBreak(s, dict))
            System.out.println("Yes it's breakable");
    }
    public static boolean wordBreak(String s,Set<String> dict) {
        Map<String, Boolean> map = new HashMap<String, Boolean>();
        return recurse(0,s,dict,map);
    }
    public static boolean recurse(int startIndex, String s, Set<String> dict, Map<String, Boolean> map) {
        int size = s.length();
        if(startIndex == size) {
            return true;
        }
        if(map.containsKey(s.substring(startIndex)))
            return map.get(s.substring(startIndex));
        int currIndex = startIndex+1;
        while(currIndex <= size) {
            String leftString = s.substring(startIndex, currIndex);
            if(dict.contains(leftString)) {
                if(recurse(currIndex,s,dict,map)) {
                    map.put(s.substring(startIndex), true);
                    return true;
                }
            }
            currIndex++;
        }
        map.put(s.substring(startIndex),false);
        return false;
    }
}

