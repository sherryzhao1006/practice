/*
Using hashset to store the char
count: max count without repeat until now if hashset doesn't contain duplicate char
if hashset contains the char which is equal to current char you can just keep popping from leftPointer until the curr char has no duplicate char in hashset
*/





public class Solution {
    /**
     * @param s: a string
     * @return: an integer 
     */
    public int lengthOfLongestSubstring(String s) {
        int count = 0;
        int max = Integer.MIN_VALUE;
        HashSet<Character> hs = new HashSet<Character>();
        int leftPointer = 0;
        
        for(int i=0; i < s.length();) {
            if(hs.contains(s.charAt(i))) {
            //if hashset contains the char which is equal to current char you can just keep popping from leftPointer until the curr char has no duplicate char in hashset
                hs.remove(s.charAt(leftPointer));
                leftPointer++;
                count--;        
            } else {
            //count: max count without repeat until now if hashset doesn't contain duplicate char

                hs.add(s.charAt(i));
                count++;
                max = Math.max(max,count);
                i++;
            }
        }
        return max ==Integer.MIN_VALUE ? 0 : max;
    }

}

